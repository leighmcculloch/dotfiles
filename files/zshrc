if [ "$ZPROF" ]; then
  zmodload zsh/zprof
fi

# Key bindings
bindkey -e  # Use emacs key bindings as base
bindkey "^P" up-line-or-search
bindkey "^N" down-line-or-search
bindkey "^[[3~" delete-char           # Delete key
bindkey "^[^?" backward-kill-word     # Alt-Backspace (delete word backward)
bindkey "^[d" kill-word               # Alt-d (delete word forward)
bindkey "^[b" backward-word           # Alt-b (move word backward)
bindkey "^[f" forward-word            # Alt-f (move word forward)

# free up the c-q shortcut for use in vim
stty start undef

source ~/.zenv

# Stub compdef to queue registrations until compinit runs
typeset -a __compdef_queue
compdef() { __compdef_queue+=("$@") }

# Process queued compdef calls after compinit
__process_compdef_queue() {
  # compinit already overwrote the stub with the real compdef
  for args in "${__compdef_queue[@]}"; do
    compdef ${=args}  # Call real compdef with queued args
  done
  unset __compdef_queue
}

# Defer compinit until first completion
function __deferred_compinit() {
  unfunction __deferred_compinit
  autoload -Uz compinit
  # Regenerate dump if older than 24 hours
  if [[ -n ~/.zcompdump(#qN.mh+24) ]]; then
    compinit
  else
    compinit -C
  fi
  (( $+functions[__process_compdef_queue] )) && __process_compdef_queue
  # Rebind Tab to real completion before sourcing fzf-tab so it captures
  # the correct fallback widget (not the now-orphaned __deferred_compinit)
  bindkey '^I' expand-or-complete
  # Load fzf-tab (must be after compinit and compdef calls)
  source "$DOTFILES/files/vendor/fzf-tab/fzf-tab.plugin.zsh"
  # Replay Tab through fzf-tab (can't call zle fzf-tab-complete directly
  # from inside another widget â€” fzf's terminal takeover glitches)
  zle -U $'\t'
}
zle -N __deferred_compinit
bindkey '^I' __deferred_compinit

# Helper to ensure compinit is loaded before registering completions
__ensure_compinit() {
  if typeset -f compdef | grep -q __compdef_queue; then
    autoload -Uz compinit
    if [[ -n ~/.zcompdump(#qN.mh+24) ]]; then
      compinit
    else
      compinit -C
    fi
    (( $+functions[__process_compdef_queue] )) && __process_compdef_queue
    # Load fzf-tab if not already loaded
    if ! (( $+functions[fzf-tab-complete] )); then
      bindkey '^I' expand-or-complete
      source "$DOTFILES/files/vendor/fzf-tab/fzf-tab.plugin.zsh"
    fi
  fi
}

# Lazy-load completions to speed up startup
# These run only when you first invoke the command

# GitHub CLI
if (( $+commands[gh] )); then
  gh() {
    unfunction gh
    (( $+functions[__ensure_compinit] )) && __ensure_compinit
    eval "$(command gh completion -s zsh)"
    command gh "$@"
  }
fi

# Stellar CLI
if (( $+commands[stellar] )); then
  stellar() {
    unfunction stellar
    (( $+functions[__ensure_compinit] )) && __ensure_compinit
    eval "$(command stellar completion --shell zsh)"
    command stellar "$@"
  }
fi

# Rustup
if (( $+commands[rustup] )); then
  rustup() {
    unfunction rustup
    (( $+functions[__ensure_compinit] )) && __ensure_compinit
    eval "$(command rustup completions zsh)"
    command rustup "$@"
  }
fi

# Tmux
if (( $+commands[tmux] )); then
  # Auto-start tmux in ghostty or SSH
  if [[ -z "$TMUX" && ("$TERM_PROGRAM" == "ghostty" || -n "$SSH_CLIENT") ]]; then
    tmux attach 2>/dev/null || tmux new-session -s main
  fi
  alias clear="tmux send-keys C-l \; send-keys -R \; clear-history"
fi

# FZF key bindings (Ctrl-R for history, Ctrl-T for files, Alt-C for cd)
if (( $+commands[fzf] )); then
  source $BREW_PREFIX/opt/fzf/shell/key-bindings.zsh
fi

# Use a simplified prompt when recording in asciinema
if [ $ASCIINEMA_REC ]; then
  PROMPT="$ "
fi

# general aliases
alias scratch="cd ~/Code/scratch/"
alias l="ls -lah"
alias p="source ~/.zenv_apikey_perplexity && deno run --allow-env=PERPLEXITY_API_KEY --allow-net=api.perplexity.ai:443 jsr:@leigh/perplexity-cli"
function caff() {
  mkdir -p /tmp/caffeinate
  pushd /tmp/caffeinate
  echo 'Preventing sleep... Ctrl-C to release.'
  trap 'popd; rm -rf /tmp/caffeinate; trap - INT; return' INT
  caffeinate -i
  trap - INT
  popd
  rm -rf /tmp/caffeinate
}
if (( $+commands[nvim] )); then
  alias vim=nvim
fi

# Git aliases
function git() {
  if command git rev-parse --git-dir >/dev/null 2>&1; then
    command git config core.hooksPath no-hooks >/dev/null 2>&1
  fi
  command git $@
}

git_main_branch() {
  command git rev-parse --git-dir &>/dev/null || return
  for ref in refs/{heads,remotes/{origin,upstream}}/{main,trunk,master}; do
    if command git show-ref -q --verify $ref; then
      echo ${ref:t}; return
    fi
  done
  echo master
}

alias g='git'
alias ga='git add'
alias gaa='git add --all'
alias 'gc!'='git commit -v --amend'
alias 'gcn!'='git commit -v --no-edit --amend'
alias gco='git checkout'
alias 'gcm'='git checkout $(git_main_branch)'
alias gd='git diff'
alias gdca='git diff --cached'
alias gf='git fetch'
alias gl='git pull'
alias gp='git push'
alias gst='git status'
alias gup='git pull --rebase'
alias grb='git rebase'
alias grbi='git rebase -i'
alias grbc='git rebase --continue'
alias grba='git rebase --abort'
alias glog='git log --oneline --decorate --graph'
alias gm='git merge'
alias gma='git merge --abort'

# git aliases (custom)
alias gcy="gc -y"
alias gcyp="gcy && gp"
alias ga.="git add ."
alias gap="git add -p"
alias 'gacn!'="ga. && gcn!"
alias gac="ga. && gcy"
alias gacp="ga. && gcy && gp"
alias gaacy="gaa && gcy"
alias gaacp="gaa && gcy && gp"
alias gaacyp="gaacp"
alias gb="git branch"
alias gde="git diff --exit-code"
alias gdcsv="git diff --color-words=\"[^[:space:],]+\""
alias gdcacsv="git diff --cached --color-words=\"[^[:space:],]+\""
alias gscsv="git show --color-words=\"[^[:space:],]+\""
alias 'gacnf!'="ga . && gcn! && gp -f"
alias gs="git stash"
alias gsp="git stash pop"
alias gsl="git stash list"
alias gupp="gup && gp"
alias gwa="git worktree add"
alias gwau='() { command gwau "$1" && cd "../${PWD##*/}-$1" ; }'
alias gwr="git worktree remove"
alias gwl="git worktree list"
alias gwp="git worktree prune"
alias grbs="git rebase --exec 'git commit --amend --no-edit -n -S' -i"

# gh aliases
alias ghco="gh co"
alias ghprme="gh pr list --author @me"
alias ghprco="gh pr checkout"

# Completion matching: partial/substring matching (like Oh My Zsh)
# Allows typing end of directory name and matching from anywhere
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|=*' 'l:|=* r:|=*'

# Color-code completions by file type (directories, executables, symlinks, etc.)
export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41:sg=30;46:tw=30;42:ow=30;43'
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# Group completions by type with labeled headers
zstyle ':completion:*' group-name ''
zstyle ':completion:*:descriptions' format '%F{yellow}-- %d --%f'
zstyle ':completion:*:warnings' format '%F{red}-- no matches --%f'

# fzf-tab: preview files and directories when completing paths
zstyle ':fzf-tab:complete:*' fzf-preview \
  'if [ -d $realpath ]; then ls -1 --color=always $realpath 2>/dev/null; elif [ -f $realpath ]; then head -50 $realpath 2>/dev/null; fi'

# zsh opts
unsetopt HIST_VERIFY
setopt COMPLETE_IN_WORD    # Complete from cursor position, not just end of word
setopt ALWAYS_TO_END       # Move cursor to end of completed word
setopt AUTO_MENU           # Show completion menu on second Tab press
setopt GLOB_DOTS           # Include dotfiles in glob completions
setopt LIST_PACKED         # Tighter completion list layout

# Bell on every new prompt. (See tmux config, which silences it on the active window.)
precmd() { print -n '\a' }

# Async stellar prompt info
# Updates STELLAR_PROMPT_INFO in the background so starship can display it without blocking
if (( $+commands[stellar] )); then
  export STELLAR_PROMPT_INFO=""
  typeset -g _STELLAR_ASYNC_FD=""

  _stellar_prompt_callback() {
    local fd=$1
    # Read result
    STELLAR_PROMPT_INFO="$(<&$fd)"
    # Clean up
    exec {fd}<&-
    zle -F $fd
    # Refresh prompt
    zle && zle reset-prompt
  }

  _stellar_prompt_precmd() {
    # Close previous fd if still open
    if [[ -n "$_STELLAR_ASYNC_FD" ]] && { : <&$_STELLAR_ASYNC_FD } 2>/dev/null; then
      zle -F $_STELLAR_ASYNC_FD
      exec {_STELLAR_ASYNC_FD}<&-
    fi

    # Start async job
    exec {_STELLAR_ASYNC_FD}< <(
      ver="v$(command stellar version --only-version-major 2>/dev/null)"
      net="$(command stellar env STELLAR_NETWORK 2>/dev/null)"
      acct="$(command stellar env STELLAR_ACCOUNT 2>/dev/null)"
      info="$ver"
      [[ -n "$net" ]] && info+=" $net"
      [[ -n "$acct" ]] && info+=" $acct"
      print -rn -- "$info"
    )

    # Register callback for when data is ready
    zle -F $_STELLAR_ASYNC_FD _stellar_prompt_callback
  }

  zle -N _stellar_prompt_callback
  autoload -Uz add-zsh-hook
  add-zsh-hook precmd _stellar_prompt_precmd
fi

# Zsh autosuggestions: fish-like suggestions as you type
# Accept suggestion: right arrow or end-of-line
# Accept word: Alt-f (forward-word)
ZSH_AUTOSUGGEST_STRATEGY=(history completion)
source "$DOTFILES/files/vendor/zsh-autosuggestions.zsh"

eval "$(starship init zsh)"

if [ "$ZPROF" ]; then
  zprof
fi
