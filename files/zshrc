if [ "$ZPROF" ]; then
  zmodload zsh/zprof
fi

# Key bindings
bindkey -e  # Use emacs key bindings as base
bindkey "^P" up-line-or-search
bindkey "^N" down-line-or-search
bindkey "^[[3~" delete-char           # Delete key
bindkey "^[^?" backward-kill-word     # Alt-Backspace (delete word backward)
bindkey "^[d" kill-word               # Alt-d (delete word forward)
bindkey "^[b" backward-word           # Alt-b (move word backward)
bindkey "^[f" forward-word            # Alt-f (move word forward)

# free up the c-q shortcut for use in vim
stty start undef

source ~/.zenv

# Defer compinit until first completion
function __deferred_compinit() {
  unfunction __deferred_compinit
  autoload -Uz compinit
  # Regenerate dump if older than 24 hours
  if [[ -n ~/.zcompdump(#qN.mh+24) ]]; then
    compinit
  else
    compinit -C
  fi
  # Re-bind Tab to the real completion widget and trigger it
  bindkey '^I' expand-or-complete
  zle expand-or-complete
}
zle -N __deferred_compinit
bindkey '^I' __deferred_compinit

# Helper to ensure compinit is loaded before registering completions
__ensure_compinit() {
  if ! typeset -f compdef > /dev/null; then
    autoload -Uz compinit
    if [[ -n ~/.zcompdump(#qN.mh+24) ]]; then
      compinit
    else
      compinit -C
    fi
    # Also rebind Tab now that compinit is loaded
    bindkey '^I' expand-or-complete
  fi
}

# Lazy-load completions to speed up startup
# These run only when you first invoke the command

# GitHub CLI
if (( $+commands[gh] )); then
  gh() {
    unfunction gh
    (( $+functions[__ensure_compinit] )) && __ensure_compinit
    eval "$(command gh completion -s zsh)"
    command gh "$@"
  }
fi

# Stellar CLI
if (( $+commands[stellar] )); then
  stellar() {
    unfunction stellar
    (( $+functions[__ensure_compinit] )) && __ensure_compinit
    eval "$(command stellar completion --shell zsh)"
    command stellar "$@"
  }
fi

# Rustup
if (( $+commands[rustup] )); then
  rustup() {
    unfunction rustup
    (( $+functions[__ensure_compinit] )) && __ensure_compinit
    eval "$(command rustup completions zsh)"
    command rustup "$@"
  }
fi

# Tmux
if (( $+commands[tmux] )); then
  # Auto-start tmux in ghostty or SSH
  if [[ -z "$TMUX" && ("$TERM_PROGRAM" == "ghostty" || -n "$SSH_CLIENT") ]]; then
    tmux attach 2>/dev/null || tmux new-session -s main
  fi
  alias clear="tmux send-keys C-l \; send-keys -R \; clear-history"
fi

# FZF key bindings (Ctrl-R for history, Ctrl-T for files)
if (( $+commands[fzf] )); then
  source $BREW_PREFIX/opt/fzf/shell/key-bindings.zsh
  export FZF_COMPLETION_TRIGGER=''  # Use FZF for tab completion (no ** trigger needed)
  # Only show current directory level for tab completion (not recursive)
  _fzf_compgen_path() { fd --max-depth 1 --hidden . "$1" 2>/dev/null | sort }
  _fzf_compgen_dir() { fd --max-depth 1 --hidden --type d . "$1" 2>/dev/null | sort }
  source $BREW_PREFIX/opt/fzf/shell/completion.zsh
fi

# Use a simplified prompt when recording in asciinema
if [ $ASCIINEMA_REC ]; then
  PROMPT="$ "
fi

# general aliases
alias l="ls -lah"
alias p="source ~/.zenv_apikey_perplexity && deno run --allow-env=PERPLEXITY_API_KEY --allow-net=api.perplexity.ai:443 jsr:@leigh/perplexity-cli"
if (( $+commands[nvim] )); then
  alias vim=nvim
fi

# Git aliases
function git() {
  if command git rev-parse --git-dir >/dev/null 2>&1; then
    command git config core.hooksPath no-hooks
  fi
  command git $@
}

git_main_branch() {
  command git rev-parse --git-dir &>/dev/null || return
  for ref in refs/{heads,remotes/{origin,upstream}}/{main,trunk,master}; do
    if command git show-ref -q --verify $ref; then
      echo ${ref:t}; return
    fi
  done
  echo master
}

alias g='git'
alias ga='git add'
alias gaa='git add --all'
alias 'gc!'='git commit -v --amend'
alias 'gcn!'='git commit -v --no-edit --amend'
alias gco='git checkout'
alias 'gcm'='git checkout $(git_main_branch)'
alias gd='git diff'
alias gdca='git diff --cached'
alias gf='git fetch'
alias gl='git pull'
alias gp='git push'
alias gst='git status'
alias gup='git pull --rebase'
alias grb='git rebase'
alias grbi='git rebase -i'
alias grbc='git rebase --continue'
alias grba='git rebase --abort'
alias glog='git log --oneline --decorate --graph'
alias gm='git merge'
alias gma='git merge --abort'

# git aliases (custom)
alias gcy="gc -y"
alias gcyp="gcy && gp"
alias ga.="git add ."
alias gap="git add -p"
alias 'gacn!'="ga. && gcn!"
alias gac="ga. && gcy"
alias gacp="ga. && gcy && gp"
alias gaacy="gaa && gcy"
alias gaacp="gaa && gcy && gp"
alias gaacyp="gaacp"
alias gb="git branch"
alias gde="git diff --exit-code"
alias gdcsv="git diff --color-words=\"[^[:space:],]+\""
alias gdcacsv="git diff --cached --color-words=\"[^[:space:],]+\""
alias gscsv="git show --color-words=\"[^[:space:],]+\""
alias 'gacnf!'="ga . && gcn! && gp -f"
alias gs="git stash"
alias gsp="git stash pop"
alias gsl="git stash list"
alias gupp="gup && gp"
alias gwa="git worktree add"
alias gwau='() { dir="../${PWD##*/}-${@}" ; git worktree prune ; git worktree add "$dir" && cd "$dir" ; }'
alias gwr="git worktree remove"
alias gwl="git worktree list"
alias gwp="git worktree prune"
alias grbs="git rebase --exec 'git commit --amend --no-edit -n -S' -i"

# gh aliases
alias ghco="gh co"
alias ghprme="gh pr list --author @me"
alias ghprco="gh pr checkout"

# Completion matching: partial/substring matching (like Oh My Zsh)
# Allows typing end of directory name and matching from anywhere
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' 'r:|=*' 'l:|=* r:|=*'

# zsh opts
unsetopt HIST_VERIFY

# Bell on every new prompt. (See tmux config, which silences it on the active window.)
precmd() { print -n '\a' }

# Async stellar prompt info
# Updates STELLAR_PROMPT_INFO in the background so starship can display it without blocking
if (( $+commands[stellar] )); then
  export STELLAR_PROMPT_INFO=""
  typeset -g _STELLAR_ASYNC_FD=""

  _stellar_prompt_callback() {
    local fd=$1
    # Read result
    STELLAR_PROMPT_INFO="$(<&$fd)"
    # Clean up
    exec {fd}<&-
    zle -F $fd
    # Refresh prompt
    zle && zle reset-prompt
  }

  _stellar_prompt_precmd() {
    # Close previous fd if still open
    if [[ -n "$_STELLAR_ASYNC_FD" ]] && { : <&$_STELLAR_ASYNC_FD } 2>/dev/null; then
      zle -F $_STELLAR_ASYNC_FD
      exec {_STELLAR_ASYNC_FD}<&-
    fi

    # Start async job
    exec {_STELLAR_ASYNC_FD}< <(
      ver="v$(command stellar version --only-version-major 2>/dev/null)"
      net="$(command stellar env STELLAR_NETWORK 2>/dev/null)"
      acct="$(command stellar env STELLAR_ACCOUNT 2>/dev/null)"
      info="$ver"
      [[ -n "$net" ]] && info+=" $net"
      [[ -n "$acct" ]] && info+=" $acct"
      print -rn -- "$info"
    )

    # Register callback for when data is ready
    zle -F $_STELLAR_ASYNC_FD _stellar_prompt_callback
  }

  zle -N _stellar_prompt_callback
  autoload -Uz add-zsh-hook
  add-zsh-hook precmd _stellar_prompt_precmd
fi

# Zsh autosuggestions: fish-like suggestions as you type
# Accept suggestion: right arrow or end-of-line
# Accept word: Alt-f (forward-word)
ZSH_AUTOSUGGEST_STRATEGY=(history completion)
source "$DOTFILES/files/vendor/zsh-autosuggestions.zsh"

eval "$(starship init zsh)"

if [ "$ZPROF" ]; then
  zprof
fi
