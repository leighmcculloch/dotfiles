#!/usr/bin/env zsh

set -o nounset

function {
  # Parse arguments
  local issue_number=""
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -i|--issue)
        issue_number="$2"
        shift 2
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done
  set -- "${args[@]}"

  # Get branch info (current, default, ancestor)
  local branch_info="$(gbinfo)"
  local current_branch="$(echo "$branch_info" | jq -r '.current_branch')"
  local default_branch="$(echo "$branch_info" | jq -r '.default_branch')"
  local ancestor_branch="$(echo "$branch_info" | jq -r '.ancestor_branch // empty')"

  # If an ancestor branch was found (and it's not the default), let user choose.
  # Otherwise just use the default branch.
  local base_branch=""
  if [[ -n "$ancestor_branch" && "$ancestor_branch" != "$default_branch" ]]; then
    local ancestor_count="$(git rev-list --count ${ancestor_branch}..HEAD)"
    local default_count="$(git rev-list --count ${default_branch}..HEAD)"
    local choice="$(gum choose --header "Base branch:" "${ancestor_branch} (${ancestor_count} commits)" "${default_branch} (${default_count} commits)")"
    base_branch="${choice% \(*}"
  else
    base_branch="$default_branch"
  fi
  echo "Base branch: ${base_branch}"

  # Get the diff between base branch and HEAD
  local diff="$(git log --patch ${base_branch}..HEAD)"
  if [ -z "$diff" ]; then
    echo "No changes detected in working directory"
    return 1
  fi

  # Build context as JSON (jq handles escaping automatically, preventing prompt injection)
  local repo_url="$(git remote get-url origin | sed 's/\.git$//')"
  local context_json=""
  if [[ -n "$issue_number" ]]; then
    local issue_json="$(gh issue view "$issue_number" --json url,number,title,body,comments)"
    echo Issue: $(<<< "$issue_json" jq -r '.url + " - " + .title')
    context_json="$(jq -n --arg repo "$repo_url" --argjson issue "$issue_json" '{
      repository: $repo,
      issue: {
        number: $issue.number,
        title: $issue.title,
        body: $issue.body,
        comments: [$issue.comments[] | {author: .author.login, body: .body}]
      }
    }')"
  else
    context_json="$(jq -n --arg repo "$repo_url" '{repository: $repo}')"
  fi

  local ai="${AI_CMD:-copilot}"
  case "$ai" in
    copilot) ai="$ai --model claude-opus-4.5" ;;
    claude) ai="$ai --model claude-opus-4-5" ;;
  esac
  local json_schema='{"type":"object","properties":{"title":{"type":"string","description":"Concise title that focuses on the impact of the change. Max 50 characters. Start with a capital letter. End without a full stop. Use imperative mood."},"what":{"type":"string","description":"Describes what has changed. Use imperative mood."},"why":{"type":"string","description":"Describe why the change is being made. Be concise with why, and avoid generic statements."}},"required":["title","what","why"]}'
  
  local prompt="You are a senior software engineer.

Given the following context and git diff, suggest a concise pull request title (max 50 characters) and description, where the description is separated into two sections. Use imperative mood, which means do not lead with a plural. e.g. Upgrade vs upgrades. Enable vs enables. Add vs adds. Be direct, eliminate filler words and phrases. Think like a journalist.

The first section is under the heading \"What\" and describes what has changed. The second section is under the heading \"Why\" and describes why the change is being made. Be concise with why, and avoid generic statements.

Start the title with a capital letter but do not end with a full stop. Use full sentences for what and why. Avoid generic phrases.

Context:
${context_json}

Git log with diff:
${diff}"

  local suggestion=""
  if [[ "$ai" == claude* ]]; then
    suggestion="$(${=ai} -p "$prompt" --json-schema "$json_schema")"
  else
    suggestion="$(${=ai} -p "$prompt

Reply only with valid JSON format {\"title\":\"\",\"what\":\"\",\"why\":\"\"}, on a single line, nothing else.")"
  fi

  if [ -z "$suggestion" ]; then
    echo "Error: Failed to get commit message from Anthropic API"
    return 1
  fi

  local suggestion_title=$(echo "$suggestion" | jq -r '.title')
  local suggestion_what=$(echo "$suggestion" | jq -r '.what')
  local suggestion_why=$(echo "$suggestion" | jq -r '.why')

  # Collect the components of the PR
  echo
  echo "### Title:"
  local title="$(gum input --width 50 --prompt '| ' --value "$suggestion_title")"
  echo "$title"
  echo
  echo "### What:"
  local what="$(gum write --width 80 --prompt '| ' --value "$suggestion_what")"
  echo "$what"
  echo
  echo "### Why:"
  local why="$(gum write --width 80 --char-limit 99999 --prompt '| ' --value "$suggestion_why")"
  echo "$why"
  echo
  echo "### Reviewer:"
  local repo_info=$(gh api '/repos/{owner}/{repo}')
  local owner=$(<<< "$repo_info" jq -r '.owner.login')
  local owner_type=$(<<< "$repo_info" jq -r '.owner.type')
  local is_private=$(<<< "$repo_info" jq -r '.private')
  local teams=()
  if [ "$owner_type" = "Organization" ]; then
    teams=("${(@f)$(gh api "/orgs/$owner/teams" --jq ".[] | \"$owner/\" + .slug")}")
  fi
  local reviewer="$(gum filter --no-limit --height 15 \
    $(gh api '/repos/{owner}/{repo}/contributors' --jq '.[].login') \
    "${teams[@]}"
  )"
  echo "$reviewer"
  echo

  # Construct the PR body
  echo "Creating pull request..."
  local body="### What
$what

### Why
$why"

  # Append the issue number to the body if provided
  if [[ -n "$issue_number" ]]; then
    body="$body

Close #$issue_number"
  fi

  # Create the PR
  gh pr create \
    --draft \
    --base "$base_branch" \
    --title "$title" \
    --body "$body" \
    --reviewer "$(echo -n "$reviewer" | tr '\n' ',')" \
    $@
  echo

  # Request Copilot review the PR
  if [[ "$owner" == "stellar" && "$is_private" == "true" ]]; then
    echo "Skipping Copilot review (private stellar repo)"
  else
    echo "Requesting review from Copilot..."
    gh pr edit --add-reviewer 'copilot-pull-request-reviewer[bot]' || true
  fi
  echo

  # Copy PR info to clipboard
  pr
} "$@"
