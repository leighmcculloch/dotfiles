#!/usr/bin/env zsh

set -o nounset
export SCRIPT=gprd

function {
  # Parse arguments
  local issue_number=""
  local context_file=""
  local args=()
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -i|--issue)
        issue_number="$2"
        shift 2
        ;;
      -f|--file)
        context_file="$2"
        shift 2
        ;;
      *)
        args+=("$1")
        shift
        ;;
    esac
  done
  set -- "${args[@]}"

  # Get branch info (current, default, ancestor)
  local branch_info="$(gbinfo)"
  local current_branch="$(echo "$branch_info" | jq -r '.current_branch')"
  local default_branch="$(echo "$branch_info" | jq -r '.default_branch')"
  local ancestor_branch="$(echo "$branch_info" | jq -r '.ancestor_branch // empty')"

  # If an ancestor branch was found (and it's not the default), let user choose.
  # Otherwise just use the default branch.
  local base_branch=""
  if [[ -n "$ancestor_branch" && "$ancestor_branch" != "$default_branch" ]]; then
    local ancestor_count="$(git rev-list --count ${ancestor_branch}..HEAD)"
    local default_count="$(git rev-list --count ${default_branch}..HEAD)"
    local choice="$(gum choose --header "Base branch:" "${ancestor_branch} (${ancestor_count} commits)" "${default_branch} (${default_count} commits)")"
    base_branch="${choice% \(*}"
  else
    base_branch="$default_branch"
  fi
  echo "Base branch: ${base_branch}"

  # Determine target repository for PR
  local tracking_remote=""
  local tracking_ref="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || true)"
  if [[ -n "$tracking_ref" ]]; then
    tracking_remote="${tracking_ref%%/*}"
  fi

  local gh_default_repo="$(gh repo set-default --view 2>/dev/null || true)"
  local gh_user="$(gh api /user --jq .login 2>/dev/null || true)"

  # Collect repos from remotes
  local -A slug_labels   # owner/repo -> comma-separated labels
  local -A slug_remotes  # owner/repo -> remote name
  local rname rurl slug
  for rname in $(git remote); do
    rurl="$(git remote get-url "$rname" 2>/dev/null || true)"
    [[ -z "$rurl" ]] && continue
    slug="$(echo "$rurl" | sed -E -e 's/\.git$//' -e 's#.*[:/]([^/]+/[^/]+)$#\1#')"
    [[ -z "$slug" ]] && continue
    local label="${rname}"
    [[ "$rname" == "$tracking_remote" ]] && label="${label}, tracking"
    slug_labels[$slug]="${slug_labels[$slug]:+${slug_labels[$slug]}, }${label}"
    [[ -z "${slug_remotes[$slug]:-}" ]] && slug_remotes[$slug]="$rname"
  done

  # Mark gh CLI default
  if [[ -n "$gh_default_repo" ]]; then
    slug_labels[$gh_default_repo]="${slug_labels[$gh_default_repo]:+${slug_labels[$gh_default_repo]}, }default"
  fi

  # Check for internal- prefixed repos in orgs of origin/upstream
  local -a orgs_checked=()
  for rname in origin upstream; do
    rurl="$(git remote get-url "$rname" 2>/dev/null || true)"
    [[ -z "$rurl" ]] && continue
    slug="$(echo "$rurl" | sed -E -e 's/\.git$//' -e 's#.*[:/]([^/]+/[^/]+)$#\1#')"
    local org="${slug%%/*}"
    local repo_base="${slug##*/}"
    (( ${orgs_checked[(Ie)$org]} )) && continue
    orgs_checked+=("$org")
    local internal_slug="${org}/internal-${repo_base}"
    [[ -n "${slug_labels[$internal_slug]:-}" ]] && continue
    if gh api "/repos/${internal_slug}" --silent 2>/dev/null; then
      slug_labels[$internal_slug]="internal"
    fi
  done

  # Check for authenticated user's fork
  if [[ -n "$gh_user" ]]; then
    local origin_slug=""
    rurl="$(git remote get-url origin 2>/dev/null || true)"
    if [[ -n "$rurl" ]]; then
      origin_slug="$(echo "$rurl" | sed -E -e 's/\.git$//' -e 's#.*[:/]([^/]+/[^/]+)$#\1#')"
    fi
    local repo_basename="${origin_slug##*/}"
    if [[ -n "$repo_basename" ]]; then
      local fork_slug="${gh_user}/${repo_basename}"
      if [[ -z "${slug_labels[$fork_slug]:-}" ]]; then
        if gh api "/repos/${fork_slug}" --silent 2>/dev/null; then
          slug_labels[$fork_slug]="fork"
        fi
      fi
    fi
  fi

  # Determine default selection: tracking remote's repo, then gh CLI default
  local default_slug=""
  if [[ -n "$tracking_remote" ]]; then
    local tracking_url="$(git remote get-url "$tracking_remote" 2>/dev/null || true)"
    if [[ -n "$tracking_url" ]]; then
      default_slug="$(echo "$tracking_url" | sed -E -e 's/\.git$//' -e 's#.*[:/]([^/]+/[^/]+)$#\1#')"
    fi
  fi
  [[ -z "$default_slug" ]] && default_slug="$gh_default_repo"

  # Build gum options with default first
  local -a gum_repo_items=()
  if [[ -n "$default_slug" && -n "${slug_labels[$default_slug]:-}" ]]; then
    gum_repo_items+=("${default_slug} (${slug_labels[$default_slug]})")
  fi
  for slug label in "${(@kv)slug_labels}"; do
    [[ "$slug" == "$default_slug" ]] && continue
    gum_repo_items+=("${slug} (${label})")
  done

  local target_repo=""
  if (( ${#gum_repo_items} == 0 )); then
    echo "Error: No repositories found"
    return 1
  elif (( ${#gum_repo_items} == 1 )); then
    target_repo="${gum_repo_items[1]%% \(*}"
  else
    local repo_choice="$(gum choose --header "Target repository:" "${gum_repo_items[@]}")"
    target_repo="${repo_choice%% \(*}"
  fi
  echo "Target: ${target_repo}"

  # Determine push remote and head ref for cross-repo PRs
  local push_remote=""
  local push_slug=""
  if [[ -n "${slug_remotes[$target_repo]:-}" ]]; then
    push_remote="${slug_remotes[$target_repo]}"
    push_slug="$target_repo"
  else
    push_remote="${tracking_remote:-origin}"
    local push_url="$(git remote get-url "$push_remote" 2>/dev/null || true)"
    push_slug="$(echo "$push_url" | sed -E -e 's/\.git$//' -e 's#.*[:/]([^/]+/[^/]+)$#\1#')"
  fi
  local head_ref="$current_branch"
  if [[ "$push_slug" != "$target_repo" ]]; then
    local push_owner="${push_slug%%/*}"
    head_ref="${push_owner}:${current_branch}"
  fi

  # Get the diff and log between base branch and HEAD
  local diff="$(git diff ${base_branch}..HEAD)"
  local log="$(git log ${base_branch}..HEAD)"
  if [ -z "$diff" ]; then
    echo "No changes detected in working directory"
    return 1
  fi

  # Build context as JSON (jq handles escaping automatically, preventing prompt injection)
  local repo_url="$(git remote get-url origin | sed 's/\.git$//')"
  local context_json=""
  local file_contents=""
  if [[ -n "$context_file" ]]; then
    if [[ ! -f "$context_file" ]]; then
      echo "Error: File not found: $context_file"
      return 1
    fi
    file_contents="$(cat "$context_file")"
    echo "Context file: $context_file"
  fi
  if [[ -n "$issue_number" ]]; then
    local issue_json="$(gh issue view "$issue_number" --json url,number,title,body,comments)"
    echo Issue: $(<<< "$issue_json" jq -r '.url + " - " + .title')
    context_json="$(jq -n --arg repo "$repo_url" --argjson issue "$issue_json" --arg file "$file_contents" '{
      repository: $repo,
      issue: {
        number: $issue.number,
        title: $issue.title,
        body: $issue.body,
        comments: [$issue.comments[] | {author: .author.login, body: .body}]
      }
    } + (if $file != "" then {additional_context: $file} else {} end)')"
  else
    context_json="$(jq -n --arg repo "$repo_url" --arg file "$file_contents" '{repository: $repo} + (if $file != "" then {additional_context: $file} else {} end)')"
  fi

  local mdm_enrolled=0
  if profiles status -type enrollment 2>/dev/null | grep -q "Yes"; then
    mdm_enrolled=1
  fi

  local ai=""
  if (( mdm_enrolled )); then
    #ai="opencode run -m github-copilot/gpt-5.2-codex"
    ai="claude --model claude-opus-4-6 -p"
  else
    ai="claude --model claude-opus-4-6 -p"
  fi

  printf "○ %s\n" "$ai"
  local start_time=$(gdate +%s%6N)
  local json_schema='{"type":"object","properties":{"title":{"type":"string","description":"Concise title that focuses on the impact of the change. Max 50 characters. Start with a capital letter. End without a full stop. Use imperative mood."},"what":{"type":"string","description":"Describes what has changed. Use imperative mood."},"why":{"type":"string","description":"Describe why the change is being made. Be concise with why, and avoid generic statements."},"questions":{"type":"array","items":{"type":"string"},"description":"Optional specific questions to ask the developer for clarity. Only ask if truly needed. Questions must be specific and pointed, not general."}},"required":["title","what","why"]}'
  
  local prompt="You are a senior software engineer.

Given the following context and git diff, suggest a concise pull request title (max 50 characters) and description, where the description is separated into two sections. Use imperative mood, which means do not lead with a plural. e.g. Upgrade vs upgrades. Enable vs enables. Add vs adds. Be direct, eliminate filler words and phrases. Think like a journalist.

The first section is under the heading \"What\" and describes what has changed. The second section is under the heading \"Why\" and describes why the change is being made. Be concise with why, and avoid generic statements.

Start the title with a capital letter but do not end with a full stop. Use full sentences for what and why. Avoid generic phrases.

If you need clarity to write a better description, you may include specific pointed questions in the questions field. Do not ask general questions like \"why was this change made?\" - instead ask specific questions like \"Is X intended to replace Y, or work alongside it?\" or \"Does this change affect Z?\". Only ask if truly needed.

If the context includes an \"additional_context\" field, it contains developer-provided notes, context, or a pre-prepared PR description. Use this to inform the title and description. If it contains a full PR description, use it as a starting point and refine it based on the actual diff.

Context:
${context_json}

Diff:
${diff}

Commit log:
Note: The commit log may contain implementation details, experimentation, and multiple attempts. Be critical about whether it represents the intent of the final change or just artifacts of the development process.
${log}"

  local suggestion=""
  if [[ "$ai" == claude* ]]; then
    suggestion="$(${=ai} "$prompt" --output-format json --json-schema "$json_schema" | jq -c '.structured_output')"
  else
    suggestion="$(${=ai} "$prompt

Reply only with valid JSON format {\"title\":\"\",\"what\":\"\",\"why\":\"\"}, on a single line, nothing else.")"
  fi
  local end_time=$(gdate +%s%6N)
  local elapsed_us=$((end_time - start_time))
  local elapsed_s=$(printf '%d.%06d' $((elapsed_us / 1000000)) $((elapsed_us % 1000000)))
  printf "\033[1A● %s (${elapsed_s}s)\033[K\n" "$ai"

  if [ -z "$suggestion" ]; then
    echo "Error: Failed to get commit message from Anthropic API"
    return 1
  fi

  # Check if AI has questions and collect answers
  local questions_json=$(echo "$suggestion" | jq -r '.questions // []')
  local questions_count=$(echo "$questions_json" | jq -r 'length')
  if [[ "$questions_count" -gt 0 ]]; then
    echo
    echo "### Questions from AI:"
    local answers=()
    for i in $(seq 0 $((questions_count - 1))); do
      local question=$(echo "$questions_json" | jq -r ".[$i]")
      echo "Q: $question"
      local answer="$(gum input --width 80 --prompt 'A: ')"
      echo "A: $answer"
      answers+=("$(jq -n --arg q "$question" --arg a "$answer" '{question: $q, answer: $a}')")
    done
    local answers_json=$(printf '%s\n' "${answers[@]}" | jq -s '.')

    # Send follow-up request with answers
    echo
    printf "○ %s (follow-up)\n" "$ai"
    local followup_prompt="$prompt

The developer answered your questions:
$(echo "$answers_json" | jq -r '.[] | "Q: " + .question + "\nA: " + .answer' )

Now provide the final title, what, and why based on this additional context. Do not ask more questions."

    local start_time2=$(gdate +%s%6N)
    if [[ "$ai" == claude* ]]; then
      suggestion="$(${=ai} -p "$followup_prompt" --output-format json --json-schema "$json_schema" | jq -c '.structured_output')"
    else
      suggestion="$(${=ai} -p "$followup_prompt

Reply only with valid JSON format {\"title\":\"\",\"what\":\"\",\"why\":\"\"}, on a single line, nothing else.")"
    fi
    local end_time2=$(gdate +%s%6N)
    local elapsed_us2=$((end_time2 - start_time2))
    local elapsed_s2=$(printf '%d.%06d' $((elapsed_us2 / 1000000)) $((elapsed_us2 % 1000000)))
    printf "\033[1A● %s (follow-up) (${elapsed_s2}s)\033[K\n" "$ai"
  fi

  local suggestion_title=$(echo "$suggestion" | jq -r '.title')
  local suggestion_what=$(echo "$suggestion" | jq -r '.what')
  local suggestion_why=$(echo "$suggestion" | jq -r '.why')

  # Collect the components of the PR
  echo
  echo "### Title:"
  local title="$(gum input --width 50 --prompt '| ' --value "$suggestion_title")"
  echo "$title"
  echo
  echo "### What:"
  local what="$(gum write --width 80 --prompt '| ' --value "$suggestion_what")"
  echo "$what"
  echo
  echo "### Why:"
  local why="$(gum write --width 80 --char-limit 99999 --prompt '| ' --value "$suggestion_why")"
  echo "$why"
  echo
  echo "### Reviewer:"
  local repo_info=$(gh api "/repos/${target_repo}")
  local owner=$(<<< "$repo_info" jq -r '.owner.login')
  local owner_type=$(<<< "$repo_info" jq -r '.owner.type')
  local is_private=$(<<< "$repo_info" jq -r '.private')
  local teams=()
  if [ "$owner_type" = "Organization" ]; then
    teams=("${(@f)$(gh api "/orgs/$owner/teams" --jq ".[] | \"$owner/\" + .slug")}")
  fi
  local reviewer="$(gum filter --no-limit --height 15 \
    $(gh api "/repos/${target_repo}/contributors" --jq '.[].login') \
    "${teams[@]}"
  )"
  echo "$reviewer"
  echo

  # Construct the PR body
  echo "Creating pull request..."
  local body="### What
$what

### Why
$why"

  # Append the issue number to the body if provided
  if [[ -n "$issue_number" ]]; then
    body="$body

Close #$issue_number"
  fi

  # Push the code
  git push -u "$push_remote" HEAD

  # Create the PR
  local pr_url="$(gh pr create \
    --repo "$target_repo" \
    --draft \
    --base "$base_branch" \
    --head "$head_ref" \
    --title "$title" \
    --body "$body" \
    --reviewer "$(echo -n "$reviewer" | tr '\n' ',')" \
    $@)"
  echo "$pr_url"
  echo

  # Open PR in browser
  open "$pr_url"

  # Request Copilot review the PR
  if [[ "$owner" == "stellar" && "$is_private" == "true" ]]; then
    echo "Skipping Copilot review (private stellar repo)"
  else
    echo "Requesting review from Copilot..."
    gh pr edit "$pr_url" --add-reviewer 'copilot-pull-request-reviewer[bot]' || true
  fi
  echo

  # Copy PR info to clipboard
  pr
} "$@"
