#!/usr/bin/env zsh
set -euo pipefail

log() { echo "==> $*" >&2 }

SCRIPT_DIR="${0:a:h}"

# Inline Dockerfile
read -r -d '' DOCKERFILE << 'DOCKERFILE_EOF' || true
# syntax=docker/dockerfile:1
# ============================================
# Base stage: common setup for both tools
# ============================================
FROM ubuntu:24.04 AS base

ARG USER
ARG UID
ARG HOME

# Install system dependencies
RUN --mount=type=cache,target=/var/cache/apt \
    --mount=type=cache,target=/var/lib/apt \
    apt-get update && apt-get install -y \
    ca-certificates \
    build-essential \
    pkg-config \
    libssl-dev \
    curl \
    git \
    unzip \
    zstd \
    jq \
    ncurses-base

# Create user with matching UID and macOS-style home path
RUN useradd -m -u ${UID} -d ${HOME} -s /bin/bash ${USER}

# Set up environment
ENV PATH="${HOME}/.local/bin:${PATH}"
USER ${USER}
WORKDIR ${HOME}

# Install Go
ENV GOPATH="${HOME}/go"
ENV GOROOT="${HOME}/.local/go"
ENV PATH="${HOME}/.local/go/bin:${HOME}/go/bin:${PATH}"
RUN --mount=type=cache,target=/tmp/downloads,uid=${UID} \
    mkdir -p ${HOME}/.local \
    && ARCH=$(dpkg --print-architecture) \
    && GO_VERSION=$(curl -fsSL https://go.dev/VERSION?m=text | head -1 | sed 's/^go//') \
    && GO_TAR=/tmp/downloads/go${GO_VERSION}.linux-${ARCH}.tar.gz \
    && [ -f "$GO_TAR" ] || curl -fsSL -o "$GO_TAR" https://go.dev/dl/go${GO_VERSION}.linux-${ARCH}.tar.gz \
    && tar -C ${HOME}/.local -xzf "$GO_TAR" \
    && go install golang.org/x/tools/gopls@latest

# Install Deno
ENV PATH="${HOME}/.deno/bin:${PATH}"
RUN --mount=type=cache,target=/tmp/downloads,uid=${UID} \
    ARCH=$(uname -m) \
    && DENO_VERSION=$(curl -fsSL https://api.github.com/repos/denoland/deno/releases/latest | jq -r '.tag_name | ltrimstr("v")') \
    && DENO_ZIP=/tmp/downloads/deno-${DENO_VERSION}-${ARCH}-unknown-linux-gnu.zip \
    && [ -f "$DENO_ZIP" ] || curl -fsSL -o "$DENO_ZIP" https://github.com/denoland/deno/releases/download/v${DENO_VERSION}/deno-${ARCH}-unknown-linux-gnu.zip \
    && unzip -o "$DENO_ZIP" -d ${HOME}/.local/bin

# Install Rust (stable + nightly) with wasm32v1-none target and rust-analyzer
ENV PATH="${HOME}/.cargo/bin:${PATH}"
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y \
    && . ${HOME}/.cargo/env \
    && rustup toolchain install stable \
    && rustup toolchain install nightly \
    && rustup target add wasm32v1-none --toolchain stable \
    && rustup target add wasm32v1-none --toolchain nightly \
    && rustup component add rust-analyzer

# Install GitHub CLI
RUN --mount=type=cache,target=/tmp/downloads,uid=${UID} \
    ARCH=$(dpkg --print-architecture) \
    && GH_VERSION=$(curl -fsSL https://api.github.com/repos/cli/cli/releases/latest | jq -r '.tag_name | ltrimstr("v")') \
    && GH_TAR=/tmp/downloads/gh_${GH_VERSION}_linux_${ARCH}.tar.gz \
    && [ -f "$GH_TAR" ] || curl -fsSL -o "$GH_TAR" https://github.com/cli/cli/releases/download/v${GH_VERSION}/gh_${GH_VERSION}_linux_${ARCH}.tar.gz \
    && tar -C ${HOME}/.local -xzf "$GH_TAR" --strip-components=1

# Install MCP servers
RUN go install github.com/github/github-mcp-server/cmd/github-mcp-server@latest
RUN deno install --global --deny-read --allow-env --allow-net npm:server-perplexity-ask
RUN deno install --global --allow-env --allow-net --allow-read=$HOME/.cache/deno/npm/registry.npmjs.org/@upstash/context7-mcp npm:@upstash/context7-mcp

ENV TERM="xterm-256color"

# ============================================
# OpenCode stage
# ============================================
FROM base AS opencode

ARG HOME

RUN curl -fsSL https://opencode.ai/install | bash

ENV PATH="${HOME}/.opencode/bin:${PATH}"
ENV OPENCODE_PERMISSION='{"edit":"allow","bash":"allow","webfetch":"allow", "websearch":"allow","external_directory":"allow"}'
ENV OPENCODE_EXPERIMENTAL=true

ENTRYPOINT ["opencode"]

# ============================================
# Claude Code stage
# ============================================
FROM base AS claude

ARG HOME

RUN curl -fsSL https://claude.ai/install.sh | bash

ENV PATH="${HOME}/.claude/bin:${PATH}"

ENTRYPOINT ["/bin/sh", "-c", "exec claude --mcp-config=$HOME/.claude/mcp.json --dangerously-skip-permissions"]

# ============================================
# Copilot CLI stage
# ============================================
FROM base AS copilot

ARG HOME

RUN curl -fsSL https://gh.io/copilot-install | bash

ENV PATH="${HOME}/.local/bin:${PATH}"

ENTRYPOINT ["/bin/sh", "-c", "exec copilot --allow-all"]
DOCKERFILE_EOF

# Select tool
TOOL="${TOOL:-$(gum choose --header "Select AI tool:" "opencode" "claude" "copilot")}"

# Build image
log "Preparing image for $TOOL..."
docker build \
  -t "$TOOL" \
  --target "$TOOL" \
  --build-arg HOME="$HOME" \
  --build-arg USER="$USER" \
  --build-arg UID="$(id -u)" \
  -f =(echo "$DOCKERFILE") \
  "$SCRIPT_DIR"

# Build volume mounts
MOUNTS=()
MOUNT_DIRS=(
  # current directory
  "$(pwd)"
  # claude code
  "$HOME/.claude.json"
  "$HOME/.claude"
  # opencode
  "$HOME/.config/opencode"
  "$HOME/.local/share/opencode"
  # copilot-cli
  "$XDG_CONFIG_HOME/.copilot"
)
# Mount common git dir if current dir or any immediate subdir is a worktree
typeset -A seen_common_dirs
for dir in "$(pwd)" "$(pwd)"/*/; do
  [[ -d "$dir" ]] || continue
  git -C "$dir" rev-parse --is-inside-work-tree &>/dev/null || continue
  git_dir="$(cd "$dir" && cd "$(git rev-parse --git-dir)" && pwd)"
  git_common_dir="$(cd "$dir" && cd "$(git rev-parse --git-common-dir)" && pwd)"
  [[ "$git_dir" != "$git_common_dir" ]] || continue
  common_dir="$(cd "$dir" && cd "$(dirname "$git_common_dir")" && pwd)"
  [[ -z "${seen_common_dirs[$common_dir]:-}" ]] || continue
  echo "adding to mounts $common_dir ($git_dir) ($git_common_dir)"
  seen_common_dirs[$common_dir]=1
  MOUNT_DIRS+=("$common_dir")
done
for dir in "${MOUNT_DIRS[@]}"; do
    MOUNTS+=(-v "${dir}:${dir}")
done

# Mount API key files if they exist (warn if missing)
KEYFILES=(
  "$HOME/.zenv_apikey_perplexity"
  "$HOME/.zenv_apikey_context7"
  "$HOME/.zenv_apikey_pushover"
  "$HOME/.zenv_apikey_github_ro"
)
for keyfile in "${KEYFILES[@]}"; do
  MOUNTS+=(-v "${keyfile}:${keyfile}:ro")
done

# Get git identity from host
GIT_USER_NAME="$(git config --global user.name 2>/dev/null || true)"
GIT_USER_EMAIL="$(git config --global user.email 2>/dev/null || true)"
log "Setting git identity in container: $GIT_USER_NAME <$GIT_USER_EMAIL>"

# Generate container name from current directory + random 2-digit suffix
CONTAINER_NAME="$(basename "$(pwd)" | tr -d '.')-$(printf '%02d' $((RANDOM % 100)))"
log "Container name: $CONTAINER_NAME"

# Load any keys needed
source "$HOME/.zenv_apikey_github_ro"
source "$HOME/.zenv_apikey_github_copilot"

# Environment variables passed through from host
ENV_PASSTHROUGH=(
  XDG_CONFIG_HOME
  GITHUB_TOKEN
  COPILOT_GITHUB_TOKEN
)

# Environment variables set explicitly
ENV_SET=(
  "GIT_AUTHOR_NAME=$GIT_USER_NAME"
  "GIT_AUTHOR_EMAIL=$GIT_USER_EMAIL"
  "GIT_COMMITTER_NAME=$GIT_USER_NAME"
  "GIT_COMMITTER_EMAIL=$GIT_USER_EMAIL"
)

log "Mounts:"
for mount in "${MOUNT_DIRS[@]}"; do
  echo "  $mount" >&2
done

log "Environment (passthrough):"
for var in "${ENV_PASSTHROUGH[@]}"; do
  echo "  $var" >&2
done

log "Running container $CONTAINER_NAME..."
# Run container
docker run --rm -it \
  --privileged=false \
  --cap-drop=ALL \
  --security-opt=no-new-privileges:true \
  --name "$CONTAINER_NAME" \
  "${MOUNTS[@]}" \
  ${ENV_PASSTHROUGH[@]/#/-e=} \
  ${ENV_SET[@]/#/-e=} \
  -w "$(pwd)" \
  "$TOOL" \
  "$@"
